{"version":3,"sources":["index.js","angular-sockjs.min.js"],"names":["define","angular","SockJS","module","provider","parser","msg","fromJson","formatter","event","data","toJson","socketFactory","$rootScope","$interval","$log","self","this","socket","multiplexer","channels","queue","registredChannels","interval","on","listener","scope","$on","options","broadcastPrefix","send","channel","c","getChannel","message","name","push","sendChannelQueueMessages","initSocket","url","address","info","onclose","checkSocket","reconnectInterval","error","Error","initChannel","WebSocketMultiplex","connected","onopen","$broadcast","onmessage","Array","isArray","length","success","toString","closeSocket","splice","close","readyState","cancel","forEach","rc","some","index","start","stop","$inject","$get","configure","opt","extend"],"mappings":"AAGAA,QACA,UACA,iBACA,SAAAC,EAAAC,GAEA,YAEAD,GAAAE,OAAA,qBACAC,SAAA,UAAA,WAUA,QAAAC,GAAAC,GACA,MAAAL,GAAAM,SAAAD,GAGA,QAAAE,GAAAC,EAAAC,GACA,MAAAT,GAAAU,QAAAF,EAAAC,IAGA,QAAAE,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAC,IA2MA,OAzMAD,GAAAE,OAAA,KACAF,EAAAG,YAAA,KACAH,EAAAI,YACAJ,EAAAK,SAEAL,EAAAM,qBACAN,EAAAO,SAAA,KASAP,EAAAQ,GAAA,SAAAf,EAAAgB,EAAAC,GACA,OAAAA,GAAAb,GAAAc,IAAAC,EAAAC,gBAAApB,EAAAgB,IAUAT,EAAAc,KAAA,SAAAC,EAAAtB,EAAAC,GACA,GAAAsB,GAAAhB,EAAAiB,WAAAF,GACAG,GAAAN,EAAApB,WAAAA,GAAAC,EAAAC,EAEA,OAAAsB,IAIAhB,EAAAK,MAAAW,EAAAG,MAAAC,KAAAF,GACAlB,EAAAqB,yBAAAL,KAJA,GAYAhB,EAAAsB,WAAA,SAAAC,GAOA,MANAvB,GAAAE,OAAA,KAEAqB,IACAX,EAAAY,QAAAD,GAGArC,EAGA0B,EAAAY,SAIAxB,EAAAE,OAAA,GAAAhB,GAAA0B,EAAAY,SACAzB,EAAA0B,KAAA,iBAAAb,EAAAY,SAEAxB,EAAAE,OAAAwB,QAAA,WACA1B,EAAAE,OAAA,WAGAF,EAAAO,SAAAT,EAAA,WACAE,EAAA2B,eACAf,EAAAgB,qBAZA7B,EAAA8B,MAAA,GAAAC,OAAA,+BAHA/B,EAAA8B,MAAA,GAAAC,OAAA,oDAuBA9B,EAAA+B,YAAA,SAAAhB,GAEA,IAAAf,EAAAE,OACA,MAAAH,GAAA8B,MAAA,GAAAC,OAAA,6DAGA,KAAAf,EACA,MAAAhB,GAAA8B,MAAA,GAAAC,OAAA,2BAGA,KAAAE,mBACA,MAAAjC,GAAA8B,MAAA,GAAAC,OAAA,wDAGA9B,GAAAG,cACAH,EAAAG,YAAA,GAAA6B,oBAAAhC,EAAAE,SAGAH,EAAA0B,KAAA,iBAAAV,EAAAI,KAAA,YAEA,IAAAH,GAAAhB,EAAAG,YAAAY,QAAAA,EAAAI,KACAH,GAAAiB,WAAA,EAEAjC,EAAAK,MAAAW,EAAAG,QACAnB,EAAAK,MAAAW,EAAAG,UAGAnB,EAAAM,kBAAAU,EAAAG,QACAnB,EAAAM,kBAAAU,EAAAG,MAAAJ,GAGAC,EAAAkB,OAAA,WACAlB,EAAAiB,WAAA,EACApC,EAAAsC,WAAAvB,EAAAC,gBAAAG,EAAAG,KAAA,UAGAH,EAAAoB,UAAA,SAAA9C,GAEA,MADAA,IAAAsB,EAAAvB,QAAAA,GAAAC,EAAAI,MACA2C,MAAAC,QAAAhD,IAAA,IAAAA,EAAAiD,QAGAjD,EAAA,GAAAkD,SACA3C,EAAAsC,WAAAvB,EAAAC,gBAAAG,EAAAG,KAAA,SAAA7B,OAEAO,GAAAsC,WAAAvB,EAAAC,gBAAAG,EAAAG,KAAA,IAAA7B,EAAA,GAAAA,EAAA,KALAS,EAAA8B,MAAA,GAAAC,OAAA,mBAAAxC,EAAAmD,cAQAzB,EAAAU,QAAA,WACAV,EAAAiB,WAAA,EACApC,EAAAsC,WAAAvB,EAAAC,gBAAAG,EAAAG,KAAA,WAGAnB,EAAAI,SAAAgB,KAAAJ,IAMAhB,EAAA0C,YAAA,WACA1C,EAAAE,SACAF,EAAAI,SAAAuC,OAAA,GACA3C,EAAAE,OAAA0C,QACA5C,EAAAE,OAAA,OAOAF,EAAA2B,YAAA,WACA,IAAA3B,EAAAE,QAAA,IAAAF,EAAAE,OAAA2C,WAAA,CACA/C,EAAAgD,OAAA9C,EAAAO,UAEAP,EAAAE,OAAA,KACAF,EAAAI,SAAA2C,QAAA,SAAAhC,GACAlB,EAAAsC,WAAAvB,EAAAC,gBAAAE,EAAAI,KAAA,YAEAnB,EAAAI,SAAAuC,OAAA,GAEA3C,EAAAsB,WAAAV,EAAAY,QACA,KAAA,GAAAwB,KAAAhD,GAAAM,kBACAN,EAAA+B,YAAA/B,EAAAM,kBAAA0C,MAUAhD,EAAAiB,WAAA,SAAAE,GACA,IAAAnB,EAAAE,OACA,MAAAH,GAAA8B,MAAA,GAAAC,OAAA,qCAEA,KAAA9B,EAAAI,SACA,MAAAL,GAAA8B,MAAA,GAAAC,OAAA,oBAGA,IAAAd,GAAA,IAQA,OAPAhB,GAAAI,SAAA6C,KAAA,SAAAlC,GACA,MAAAA,GAAAI,OAAAA,GACAH,EAAAD,GACA,IAEA,IAEAC,GAAAhB,EAAAI,SAAA,IAQAJ,EAAAqB,yBAAA,SAAAN,GACA,MAAAA,IAAAA,EAAAkB,WAAAjC,EAAAK,MAAAU,EAAAI,MAAAoB,QACAvC,EAAAK,MAAAU,EAAAI,MAAA4B,QAAA,SAAAzD,EAAA4D,SACAlD,GAAAK,MAAAU,EAAAI,MAAA+B,GACAnC,EAAAD,KAAAxB,KAEAU,EAAAK,MAAAU,EAAAI,MAAAwB,OAAA,IACA,IAEA,IAIAQ,MAAAnD,EAAAsB,WACA8B,KAAApD,EAAA0C,YACAX,YAAA/B,EAAA+B,YACAjB,KAAAd,EAAAc,KACAN,GAAAR,EAAAQ,GACAN,OAAA,WACA,MAAAF,GAAAE,SCnOYN,EAAcyD,SAAW,aAAc,YAAa,ODAhE,IAAAzC,IACAY,QAAA,KACAX,gBAAA,WACAe,kBAAA,IACAvC,OAAA,KACAG,UAAA,KAoOAS,MAAAqD,KAAA1D,EAEAK,KAAAsD,UAAA,SAAAC,GACAvE,EAAAwE,OAAA7C,EAAA4C","file":"angular-sockjs.min.js","sourcesContent":["/*jslint browser: true, nomen: true, plusplus: true, vars: true, eqeq: true*/\n/*global define, require, angular */\n\ndefine([\n    'angular',\n    'sockjs-client'\n], function (angular, SockJS) {\n\n    \"use strict\";\n\n    angular.module('angular-sockjs', [])\n        .provider(\"$socket\", function () {\n\n            var options = {\n                address: null,\n                broadcastPrefix: \"$socket.\",\n                reconnectInterval: 3000,\n                parser: null,\n                formatter: null\n            };\n\n            function parser(msg) {\n                return angular.fromJson(msg);\n            }\n\n            function formatter(event, data) {\n                return angular.toJson([event, data]);\n            }\n\n            function socketFactory($rootScope, $interval, $log) {\n                var self = this;\n\n                self.socket = null;\n                self.multiplexer = null;\n                self.channels = [];\n                self.queue = [];\n\n                self.registredChannels = [];\n                self.interval = null;\n\n                /**\n                 * Attaches listener on $rootScope or to the provided scope\n                 * @param event\n                 * @param listener\n                 * @param scope\n                 * @returns {*|(function())}\n                 */\n                self.on = function (event, listener, scope) {\n                    return (scope || $rootScope).$on(options.broadcastPrefix + event, listener);\n                };\n\n                /**\n                 * Sends the message if connected or queues it for later\n                 * @param channel\n                 * @param event\n                 * @param data\n                 * @returns {boolean}\n                 */\n                self.send = function (channel, event, data) {\n                    var c = self.getChannel(channel);\n                    var message = (options.formatter || formatter)(event, data);\n\n                    if (!c) {\n                        return false;\n                    }\n\n                    self.queue[c.name].push(message);\n                    return self.sendChannelQueueMessages(c);\n                };\n\n                /**\n                 * Init new socket\n                 * @param url\n                 * @returns {*}\n                 */\n                self.initSocket = function (url) {\n                    self.socket = null;\n\n                    if (url) {\n                        options.address = url;\n                    }\n\n                    if (!SockJS) {\n                        return $log.error(new Error(\"Must include SockJS for angular-sockjs to work\"));\n                    }\n                    if (!options.address) {\n                        return $log.error(new Error(\"Must configure the address\"));\n                    }\n\n                    self.socket = new SockJS(options.address);\n                    $log.info('Connecting to ' + options.address);\n\n                    self.socket.onclose = function() {\n                        self.socket = null;\n                    };\n\n                    self.interval = $interval(function() {\n                        self.checkSocket();\n                    }, options.reconnectInterval);\n                };\n\n                /**\n                 * Init new channel\n                 * @param channel\n                 * @returns {*}\n                 */\n                self.initChannel = function (channel) {\n\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket must be started before channel, see start() method\"));\n                    }\n\n                    if (!channel) {\n                        return $log.error(new Error(\"Channel must be defined\"));\n                    }\n\n                    if (!WebSocketMultiplex) {\n                        return $log.error(new Error(\"Must include WebSocketMultiplex for channels to work\"));\n                    }\n\n                    if (!self.multiplexer) {\n                        self.multiplexer = new WebSocketMultiplex(self.socket);\n                    }\n\n                    $log.info('Initializing \"' + channel.name + '\" channel');\n\n                    var c = self.multiplexer.channel(channel.name);\n                    c.connected = false;\n\n                    if (!self.queue[c.name]) {\n                        self.queue[c.name] = [];\n                    }\n\n                    if (!self.registredChannels[c.name]) {\n                        self.registredChannels[c.name] = channel;\n                    }\n\n                    c.onopen = function() {\n                        c.connected = true;\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".open\");\n                    };\n\n                    c.onmessage = function(msg) {\n                        msg = (options.parser || parser)(msg.data);\n                        if (!Array.isArray(msg) || msg.length !== 2) {\n                            return $log.error(new Error(\"Invalid message \" + msg.toString()));\n                        }\n                        if (!msg[1].success) {\n                            $rootScope.$broadcast(options.broadcastPrefix + c.name + \".error\", msg);\n                        }\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".\" + msg[0], msg[1]);\n                    };\n\n                    c.onclose = function() {\n                        c.connected = false;\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".close\");\n                    };\n\n                    self.channels.push(c);\n                };\n\n                /**\n                 * Close socket and associated channels\n                 */\n                self.closeSocket = function () {\n                    if (self.socket) {\n                        self.channels.splice(0);\n                        self.socket.close();\n                        self.socket = null;\n                    }\n                };\n\n                /**\n                 * Checks if socket is opened\n                 */\n                self.checkSocket = function () {\n                    if (!self.socket || self.socket.readyState === 3) {\n                        $interval.cancel(self.interval);\n\n                        self.socket = null;\n                        self.channels.forEach(function(channel) {\n                            $rootScope.$broadcast(options.broadcastPrefix + channel.name + \".close\");\n                        });\n                        self.channels.splice(0);\n\n                        self.initSocket(options.address);\n                        for (var rc in self.registredChannels) {\n                            self.initChannel(self.registredChannels[rc]);\n                        }\n                    }\n                };\n\n                /**\n                 * Return channel by name\n                 * @param name\n                 * @returns {*}\n                 */\n                self.getChannel = function (name) {\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket connection not initialized\"));\n                    }\n                    if (!self.channels) {\n                        return $log.error(new Error(\"No channel found\"));\n                    }\n\n                    var c = null;\n                    self.channels.some(function(channel) {\n                        if (channel.name === name) {\n                            c = channel;\n                            return true;\n                        }\n                        return false;\n                    });\n                    return c || self.channels[0];\n                };\n\n                /**\n                 * Sends messages stored in the queue\n                 * @param channel\n                 * @returns {boolean}\n                 */\n                self.sendChannelQueueMessages = function (channel) {\n                    if (channel && channel.connected && self.queue[channel.name].length) {\n                        self.queue[channel.name].forEach(function(msg, index) {\n                            delete self.queue[channel.name][index];\n                            channel.send(msg);\n                        });\n                        self.queue[channel.name].splice(0);\n                        return true;\n                    }\n                    return false;\n                };\n\n                return {\n                    start: self.initSocket,\n                    stop: self.closeSocket,\n                    initChannel: self.initChannel,\n                    send: self.send,\n                    on: self.on,\n                    socket: function() {\n                        return self.socket;\n                    }\n                };\n            }\n\n\n            this.$get = socketFactory;\n\n            this.configure = function(opt) {\n                angular.extend(options, opt);\n            };\n\n        });\n});\n","/*jslint browser: true, nomen: true, plusplus: true, vars: true, eqeq: true*/\n/*global define, require, angular */\n\ndefine([\n    'angular',\n    'sockjs-client'\n], function (angular, SockJS) {\n\n    \"use strict\";\n\n    angular.module('angular-sockjs', [])\n        .provider(\"$socket\", function () {\n\n            socketFactory.$inject = [\"$rootScope\", \"$interval\", \"$log\"];\n            var options = {\n                address: null,\n                broadcastPrefix: \"$socket.\",\n                reconnectInterval: 3000,\n                parser: null,\n                formatter: null\n            };\n\n            function parser(msg) {\n                return angular.fromJson(msg);\n            }\n\n            function formatter(event, data) {\n                return angular.toJson([event, data]);\n            }\n\n            function socketFactory($rootScope, $interval, $log) {\n                var self = this;\n\n                self.socket = null;\n                self.multiplexer = null;\n                self.channels = [];\n                self.queue = [];\n\n                self.registredChannels = [];\n                self.interval = null;\n\n                /**\n                 * Attaches listener on $rootScope or to the provided scope\n                 * @param event\n                 * @param listener\n                 * @param scope\n                 * @returns {*|(function())}\n                 */\n                self.on = function (event, listener, scope) {\n                    return (scope || $rootScope).$on(options.broadcastPrefix + event, listener);\n                };\n\n                /**\n                 * Sends the message if connected or queues it for later\n                 * @param channel\n                 * @param event\n                 * @param data\n                 * @returns {boolean}\n                 */\n                self.send = function (channel, event, data) {\n                    var c = self.getChannel(channel);\n                    var message = (options.formatter || formatter)(event, data);\n\n                    if (!c) {\n                        return false;\n                    }\n\n                    self.queue[c.name].push(message);\n                    return self.sendChannelQueueMessages(c);\n                };\n\n                /**\n                 * Init new socket\n                 * @param url\n                 * @returns {*}\n                 */\n                self.initSocket = function (url) {\n                    self.socket = null;\n\n                    if (url) {\n                        options.address = url;\n                    }\n\n                    if (!SockJS) {\n                        return $log.error(new Error(\"Must include SockJS for angular-sockjs to work\"));\n                    }\n                    if (!options.address) {\n                        return $log.error(new Error(\"Must configure the address\"));\n                    }\n\n                    self.socket = new SockJS(options.address);\n                    $log.info('Connecting to ' + options.address);\n\n                    self.socket.onclose = function() {\n                        self.socket = null;\n                    };\n\n                    self.interval = $interval(function() {\n                        self.checkSocket();\n                    }, options.reconnectInterval);\n                };\n\n                /**\n                 * Init new channel\n                 * @param channel\n                 * @returns {*}\n                 */\n                self.initChannel = function (channel) {\n\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket must be started before channel, see start() method\"));\n                    }\n\n                    if (!channel) {\n                        return $log.error(new Error(\"Channel must be defined\"));\n                    }\n\n                    if (!WebSocketMultiplex) {\n                        return $log.error(new Error(\"Must include WebSocketMultiplex for channels to work\"));\n                    }\n\n                    if (!self.multiplexer) {\n                        self.multiplexer = new WebSocketMultiplex(self.socket);\n                    }\n\n                    $log.info('Initializing \"' + channel.name + '\" channel');\n\n                    var c = self.multiplexer.channel(channel.name);\n                    c.connected = false;\n\n                    if (!self.queue[c.name]) {\n                        self.queue[c.name] = [];\n                    }\n\n                    if (!self.registredChannels[c.name]) {\n                        self.registredChannels[c.name] = channel;\n                    }\n\n                    c.onopen = function() {\n                        c.connected = true;\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".open\");\n                    };\n\n                    c.onmessage = function(msg) {\n                        msg = (options.parser || parser)(msg.data);\n                        if (!Array.isArray(msg) || msg.length !== 2) {\n                            return $log.error(new Error(\"Invalid message \" + msg.toString()));\n                        }\n                        if (!msg[1].success) {\n                            $rootScope.$broadcast(options.broadcastPrefix + c.name + \".error\", msg);\n                        }\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".\" + msg[0], msg[1]);\n                    };\n\n                    c.onclose = function() {\n                        c.connected = false;\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".close\");\n                    };\n\n                    self.channels.push(c);\n                };\n\n                /**\n                 * Close socket and associated channels\n                 */\n                self.closeSocket = function () {\n                    if (self.socket) {\n                        self.channels.splice(0);\n                        self.socket.close();\n                        self.socket = null;\n                    }\n                };\n\n                /**\n                 * Checks if socket is opened\n                 */\n                self.checkSocket = function () {\n                    if (!self.socket || self.socket.readyState === 3) {\n                        $interval.cancel(self.interval);\n\n                        self.socket = null;\n                        self.channels.forEach(function(channel) {\n                            $rootScope.$broadcast(options.broadcastPrefix + channel.name + \".close\");\n                        });\n                        self.channels.splice(0);\n\n                        self.initSocket(options.address);\n                        for (var rc in self.registredChannels) {\n                            self.initChannel(self.registredChannels[rc]);\n                        }\n                    }\n                };\n\n                /**\n                 * Return channel by name\n                 * @param name\n                 * @returns {*}\n                 */\n                self.getChannel = function (name) {\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket connection not initialized\"));\n                    }\n                    if (!self.channels) {\n                        return $log.error(new Error(\"No channel found\"));\n                    }\n\n                    var c = null;\n                    self.channels.some(function(channel) {\n                        if (channel.name === name) {\n                            c = channel;\n                            return true;\n                        }\n                        return false;\n                    });\n                    return c || self.channels[0];\n                };\n\n                /**\n                 * Sends messages stored in the queue\n                 * @param channel\n                 * @returns {boolean}\n                 */\n                self.sendChannelQueueMessages = function (channel) {\n                    if (channel && channel.connected && self.queue[channel.name].length) {\n                        self.queue[channel.name].forEach(function(msg, index) {\n                            delete self.queue[channel.name][index];\n                            channel.send(msg);\n                        });\n                        self.queue[channel.name].splice(0);\n                        return true;\n                    }\n                    return false;\n                };\n\n                return {\n                    start: self.initSocket,\n                    stop: self.closeSocket,\n                    initChannel: self.initChannel,\n                    send: self.send,\n                    on: self.on,\n                    socket: function() {\n                        return self.socket;\n                    }\n                };\n            }\n\n\n            this.$get = socketFactory;\n\n            this.configure = function(opt) {\n                angular.extend(options, opt);\n            };\n\n        });\n});\n"],"sourceRoot":"/source/"}