{"version":3,"sources":["index.js","angular-sockjs.min.js"],"names":["define","angular","SockJS","module","provider","parser","msg","fromJson","formatter","event","data","toJson","socketFactory","$rootScope","$interval","$log","on","listener","scope","$on","options","broadcastPrefix","send","channel","c","self","getChannel","message","queue","name","push","sendChannelQueues","initSocket","url","socket","address","info","interval","checkSocket","reconnectInterval","error","Error","initChannel","WebSocketMultiplex","multiplexer","connected","onopen","$broadcast","onmessage","Array","isArray","length","success","toString","onclose","channels","this","readyState","cancel","forEach","some","splice","start","$inject","$get","configure","opt","extend"],"mappings":"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","file":"angular-sockjs.min.js","sourcesContent":["/*jslint browser: true, nomen: true, plusplus: true, vars: true, eqeq: true*/\n/*global define, require, angular */\n\ndefine([\n    'angular',\n    'sockjs-client'\n], function (angular, SockJS) {\n\n    \"use strict\";\n\n    angular.module('angular-sockjs', [])\n    .provider(\"$socket\", function () {\n\n        var options = {\n            address: null,\n            broadcastPrefix: \"$socket.\",\n            reconnectInterval: 3000,\n            parser: null,\n            formatter: null\n        };\n\n        function parser(msg) {\n            return angular.fromJson(msg);\n        }\n\n        function formatter(event, data) {\n            return angular.toJson([event, data]);\n        }\n\n        function socketFactory($rootScope, $interval, $log) {\n            var self = this;\n\n            self.socket = null;\n            self.multiplexer = null;\n            self.channels = [];\n            self.queue = [];\n\n            self.interval = null;\n\n            /**\n             * Attaches listener on $rootScope or to the provided scope\n             * @param event\n             * @param listener\n             * @param scope\n             * @returns {*|(function())}\n             */\n            function on(event, listener, scope) {\n                return (scope || $rootScope).$on(options.broadcastPrefix + event, listener);\n            }\n\n            /**\n             * Sends the message if connected or queues it for later\n             * @param channel\n             * @param event\n             * @param data\n             * @returns {boolean}\n             */\n            function send(channel, event, data) {\n                var c = self.getChannel(channel);\n                var message = (options.formatter || formatter)(event, data);\n\n                self.queue[c.name].push(message);\n                return self.sendChannelQueues(c);\n            }\n\n            /**\n             * Init new socket\n             * @param url\n             * @returns {*}\n             */\n            function initSocket(url) {\n                self.socket = null;\n\n                if (url) {\n                    options.address = url;\n                }\n\n                if (!SockJS) {\n                    return $log.error(new Error(\"Must include SockJS for angular-sockjs to work\"));\n                }\n                if (!options.address) {\n                    return $log.error(new Error(\"Must configure the address\"));\n                }\n\n                self.socket = new SockJS(options.address);\n                $log.info('Connecting to ' + options.address);\n\n                self.interval = $interval(function() {\n                    self.checkSocket(url);\n                }, options.reconnectInterval);\n            }\n\n            /**\n             * Init new channel\n             * @param channel\n             * @returns {*}\n             */\n            function initChannel(channel) {\n\n                if (!self.socket) {\n                    return $log.error(new Error(\"Socket must be started before channel, see start() method\"));\n                }\n\n                if (!channel) {\n                    return $log.error(new Error(\"Channel must be defined\"));\n                }\n\n                if (!WebSocketMultiplex) {\n                    return $log.error(new Error(\"Must include WebSocketMultiplex for channels to work\"));\n                }\n\n                if (!self.multiplexer) {\n                    self.multiplexer = new WebSocketMultiplex(self.socket);\n                }\n\n                $log.info('Initializing \"' + channel.name + '\" channel');\n\n                var c = self.multiplexer.channel(channel.name);\n                c.connected = false;\n\n                if (!self.queue[c.name]) {\n                    self.queue[c.name] = [];\n                }\n\n                c.onopen = function() {\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".open\");\n                    c.connected = true;\n                };\n\n                c.onmessage = function(msg) {\n                    msg = (options.parser || parser)(msg.data);\n                    if (!Array.isArray(msg) || msg.length !== 2) {\n                        return $log.error(new Error(\"Invalid message \" + msg.toString()));\n                    }\n                    if (!msg[1].success) {\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".error\", msg);\n                    }\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".\" + msg[0], msg[1]);\n                };\n\n                c.onclose = function() {\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".close\");\n                    self.socket = null;\n                    c.connected = false;\n                };\n\n                self.channels.push(c);\n            }\n\n            /**\n             * Checks if socket opened\n             * @param url\n             */\n            self.checkSocket = function (url) {\n                if (!self.socket || self.socket.readyState === 3) {\n                    self.socket = null;\n                    $interval.cancel(self.interval);\n                    self.channels.forEach(function(channel) {\n                        $rootScope.$broadcast(options.broadcastPrefix + channel.name + \".close\");\n                    });\n                    initSocket(url);\n                }\n            };\n\n            /**\n             * Return channel by name\n             * @param name\n             * @returns {*}\n             */\n            self.getChannel = function (name) {\n                if (!self.socket || !self.channels) {\n                    return $log.error(new Error(\"No channel found !\"));\n                }\n\n                var c = null;\n                self.channels.some(function(channel) {\n                    if (channel.name === name) {\n                        c = channel;\n                        return true;\n                    }\n                    return false;\n                });\n                return c || self.channels[0];\n            };\n\n            self.sendChannelQueues = function (channel) {\n                if (channel && channel.connected && self.queue[channel.name].length) {\n                    self.queue[channel.name].forEach(function(msg) {\n                        delete self.queue[channel.name][msg];\n                        channel.send(msg);\n                    });\n                    self.queue[channel.name].splice(0);\n                    return true;\n                }\n                return false;\n            };\n\n            return {\n                start: initSocket,\n                initChannel: initChannel,\n                send: send,\n                on: on,\n                socket: function() {\n                    return socket;\n                }\n            };\n        }\n\n\n        this.$get = socketFactory;\n\n        this.configure = function(opt) {\n            angular.extend(options, opt);\n        };\n\n    });\n});\n","/*jslint browser: true, nomen: true, plusplus: true, vars: true, eqeq: true*/\n/*global define, require, angular */\n\ndefine([\n    'angular',\n    'sockjs-client'\n], function (angular, SockJS) {\n\n    \"use strict\";\n\n    angular.module('angular-sockjs', [])\n    .provider(\"$socket\", function () {\n\n        socketFactory.$inject = [\"$rootScope\", \"$interval\", \"$log\"];\n        var options = {\n            address: null,\n            broadcastPrefix: \"$socket.\",\n            reconnectInterval: 3000,\n            parser: null,\n            formatter: null\n        };\n\n        function parser(msg) {\n            return angular.fromJson(msg);\n        }\n\n        function formatter(event, data) {\n            return angular.toJson([event, data]);\n        }\n\n        function socketFactory($rootScope, $interval, $log) {\n            var self = this;\n\n            self.socket = null;\n            self.multiplexer = null;\n            self.channels = [];\n            self.queue = [];\n\n            self.interval = null;\n\n            /**\n             * Attaches listener on $rootScope or to the provided scope\n             * @param event\n             * @param listener\n             * @param scope\n             * @returns {*|(function())}\n             */\n            function on(event, listener, scope) {\n                return (scope || $rootScope).$on(options.broadcastPrefix + event, listener);\n            }\n\n            /**\n             * Sends the message if connected or queues it for later\n             * @param channel\n             * @param event\n             * @param data\n             * @returns {boolean}\n             */\n            function send(channel, event, data) {\n                var c = self.getChannel(channel);\n                var message = (options.formatter || formatter)(event, data);\n\n                self.queue[c.name].push(message);\n                return self.sendChannelQueues(c);\n            }\n\n            /**\n             * Init new socket\n             * @param url\n             * @returns {*}\n             */\n            function initSocket(url) {\n                self.socket = null;\n\n                if (url) {\n                    options.address = url;\n                }\n\n                if (!SockJS) {\n                    return $log.error(new Error(\"Must include SockJS for angular-sockjs to work\"));\n                }\n                if (!options.address) {\n                    return $log.error(new Error(\"Must configure the address\"));\n                }\n\n                self.socket = new SockJS(options.address);\n                $log.info('Connecting to ' + options.address);\n\n                self.interval = $interval(function() {\n                    self.checkSocket(url);\n                }, options.reconnectInterval);\n            }\n\n            /**\n             * Init new channel\n             * @param channel\n             * @returns {*}\n             */\n            function initChannel(channel) {\n\n                if (!self.socket) {\n                    return $log.error(new Error(\"Socket must be started before channel, see start() method\"));\n                }\n\n                if (!channel) {\n                    return $log.error(new Error(\"Channel must be defined\"));\n                }\n\n                if (!WebSocketMultiplex) {\n                    return $log.error(new Error(\"Must include WebSocketMultiplex for channels to work\"));\n                }\n\n                if (!self.multiplexer) {\n                    self.multiplexer = new WebSocketMultiplex(self.socket);\n                }\n\n                $log.info('Initializing \"' + channel.name + '\" channel');\n\n                var c = self.multiplexer.channel(channel.name);\n                c.connected = false;\n\n                if (!self.queue[c.name]) {\n                    self.queue[c.name] = [];\n                }\n\n                c.onopen = function() {\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".open\");\n                    c.connected = true;\n                };\n\n                c.onmessage = function(msg) {\n                    msg = (options.parser || parser)(msg.data);\n                    if (!Array.isArray(msg) || msg.length !== 2) {\n                        return $log.error(new Error(\"Invalid message \" + msg.toString()));\n                    }\n                    if (!msg[1].success) {\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".error\", msg);\n                    }\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".\" + msg[0], msg[1]);\n                };\n\n                c.onclose = function() {\n                    $rootScope.$broadcast(options.broadcastPrefix + c.name + \".close\");\n                    self.socket = null;\n                    c.connected = false;\n                };\n\n                self.channels.push(c);\n            }\n\n            /**\n             * Checks if socket opened\n             * @param url\n             */\n            self.checkSocket = function (url) {\n                if (!self.socket || self.socket.readyState === 3) {\n                    self.socket = null;\n                    $interval.cancel(self.interval);\n                    self.channels.forEach(function(channel) {\n                        $rootScope.$broadcast(options.broadcastPrefix + channel.name + \".close\");\n                    });\n                    initSocket(url);\n                }\n            };\n\n            /**\n             * Return channel by name\n             * @param name\n             * @returns {*}\n             */\n            self.getChannel = function (name) {\n                if (!self.socket || !self.channels) {\n                    return $log.error(new Error(\"No channel found !\"));\n                }\n\n                var c = null;\n                self.channels.some(function(channel) {\n                    if (channel.name === name) {\n                        c = channel;\n                        return true;\n                    }\n                    return false;\n                });\n                return c || self.channels[0];\n            };\n\n            self.sendChannelQueues = function (channel) {\n                if (channel && channel.connected && self.queue[channel.name].length) {\n                    self.queue[channel.name].forEach(function(msg) {\n                        delete self.queue[channel.name][msg];\n                        channel.send(msg);\n                    });\n                    self.queue[channel.name].splice(0);\n                    return true;\n                }\n                return false;\n            };\n\n            return {\n                start: initSocket,\n                initChannel: initChannel,\n                send: send,\n                on: on,\n                socket: function() {\n                    return socket;\n                }\n            };\n        }\n\n\n        this.$get = socketFactory;\n\n        this.configure = function(opt) {\n            angular.extend(options, opt);\n        };\n\n    });\n});\n"],"sourceRoot":"/source/"}