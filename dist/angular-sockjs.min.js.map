{"version":3,"sources":["index.js"],"names":["define","angular","SockJS","module","provider","parser","msg","fromJson","formatter","event","data","toJson","socketFactory","$rootScope","$interval","$log","self","this","socket","multiplexer","channels","queue","registredChannels","interval","on","listener","scope","$on","options","broadcastPrefix","send","channel","c","getChannel","message","debug","name","push","sendChannelQueueMessages","initSocket","url","splice","address","WebSocketMultiplex","info","onopen","onclose","connected","$broadcast","checkSocket","reconnectInterval","error","Error","initChannel","setTimeout","readyState","onmessage","Array","isArray","length","success","toString","closeSocket","close","cancel","rc","some","forEach","index","start","stop","$inject","$get","configure","opt","extend"],"mappings":"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","file":"angular-sockjs.min.js","sourcesContent":["/*jslint browser: true, nomen: true, plusplus: true, vars: true, eqeq: true*/\n/*global define, require, angular */\n\ndefine([\n    'angular',\n    'sockjs-client'\n], function (angular, SockJS) {\n\n    \"use strict\";\n\n    angular.module('angular-sockjs', [])\n        .provider(\"$socket\", function () {\n\n            socketFactory.$inject = [\"$rootScope\", \"$interval\", \"$log\"];\n            var options = {\n                address: null,\n                broadcastPrefix: \"$socket.\",\n                reconnectInterval: 3000,\n                parser: null,\n                formatter: null\n            };\n\n            function parser(msg) {\n                return angular.fromJson(msg);\n            }\n\n            function formatter(event, data) {\n                return angular.toJson([event, data]);\n            }\n\n            function socketFactory($rootScope, $interval, $log) {\n                var self = this;\n\n                self.socket = null;\n                self.multiplexer = null;\n                self.channels = [];\n                self.queue = [];\n\n                self.registredChannels = [];\n                self.interval = null;\n\n                /**\n                 * Attaches listener on $rootScope or to the provided scope\n                 * @param event\n                 * @param listener\n                 * @param scope\n                 * @returns {*|(function())}\n                 */\n                self.on = function (event, listener, scope) {\n                    return (scope || $rootScope).$on(options.broadcastPrefix + event, listener);\n                };\n\n                /**\n                 * Sends the message if connected or queues it for later\n                 * @param channel\n                 * @param event\n                 * @param data\n                 * @returns {boolean}\n                 */\n                self.send = function (channel, event, data) {\n                    var c = self.getChannel(channel);\n                    var message = (options.formatter || formatter)(event, data);\n\n                    $log.debug('Sending', event, 'on', c.name);\n                    if (!c) {\n                        return false;\n                    }\n\n                    self.queue[c.name].push(message);\n                    return self.sendChannelQueueMessages(c);\n                };\n\n                /**\n                 * Init new socket\n                 * @param url\n                 * @returns {*}\n                 */\n                self.initSocket = function (url) {\n                    self.socket = self.multiplexer = null;\n                    self.channels.splice(0);\n\n                    if (url) {\n                        options.address = url;\n                    }\n\n                    if (!SockJS) {\n                        return $log.error(new Error(\"Must include SockJS for angular-sockjs to work\"));\n                    }\n                    if (!options.address) {\n                        return $log.error(new Error(\"Must configure the address\"));\n                    }\n\n                    if (!WebSocketMultiplex) {\n                        return $log.error(new Error(\"Must include WebSocketMultiplex for channels to work\"));\n                    }\n\n                    self.socket = new SockJS(options.address);\n                    self.multiplexer = new WebSocketMultiplex(self.socket);\n                    $log.info('Connecting to ' + options.address);\n\n                    self.socket.onopen = function() {\n                        $log.debug('Socket onopen event called');\n                    };\n\n                    self.socket.onclose = function() {\n                        $log.debug('Socket onclose event called');\n                        for (var c in self.channels) {\n                            self.channels[c].connected = false;\n                            $rootScope.$broadcast(options.broadcastPrefix + self.channels[c].name + \".close\");\n                        }\n                    };\n\n                    self.interval = $interval(function() {\n                        self.checkSocket();\n                    }, options.reconnectInterval);\n                };\n\n                /**\n                 * Init new channel\n                 * @param channel\n                 * @returns {*}\n                 */\n                self.initChannel = function (channel) {\n\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket must be started before channel, see start() method\"));\n                    }\n\n                    if (!channel) {\n                        return $log.error(new Error(\"Channel must be defined\"));\n                    }\n\n                    $log.info('Initializing \"' + channel.name + '\" channel');\n\n                    var c = self.multiplexer.channel(channel.name);\n                    c.connected = false;\n\n                    if (!self.queue[c.name]) {\n                        self.queue[c.name] = [];\n                    }\n\n                    if (!self.registredChannels[c.name]) {\n                        self.registredChannels[c.name] = channel;\n                    }\n\n                    c.onopen = function() {\n                        c.connected = true;\n                        setTimeout(function() {\n                            if (self.socket && self.socket.readyState === 1) {\n                                $rootScope.$broadcast(options.broadcastPrefix + c.name + \".open\");\n                            }\n                        }, 200);\n                    };\n\n                    c.onmessage = function(msg) {\n                        msg = (options.parser || parser)(msg.data);\n                        if (!Array.isArray(msg) || msg.length !== 2) {\n                            return $log.error(new Error(\"Invalid message \" + msg.toString()));\n                        }\n                        if (!msg[1].success) {\n                            $rootScope.$broadcast(options.broadcastPrefix + c.name + \".error\", msg);\n                        }\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".\" + msg[0], msg[1]);\n                    };\n\n                    c.onclose = function() {\n                        c.connected = false;\n                        $rootScope.$broadcast(options.broadcastPrefix + c.name + \".close\");\n                    };\n\n                    self.channels.push(c);\n                };\n\n                /**\n                 * Close socket and associated channels\n                 */\n                self.closeSocket = function () {\n                    if (self.socket) {\n                        self.channels.splice(0);\n                        self.socket.close();\n                        self.socket = null;\n                    }\n                };\n\n                /**\n                 * Checks if socket is opened\n                 */\n                self.checkSocket = function () {\n                    if (self.socket) {\n                        if (self.socket.readyState === 3) {\n                            $interval.cancel(self.interval);\n                            self.initSocket(options.address);\n                            for (var rc in self.registredChannels) {\n                                self.initChannel(self.registredChannels[rc]);\n                            }\n                        }\n                    }\n                };\n\n                /**\n                 * Return channel by name\n                 * @param name\n                 * @returns {*}\n                 */\n                self.getChannel = function (name) {\n                    if (!self.socket) {\n                        return $log.error(new Error(\"Socket connection not initialized\"));\n                    }\n                    if (!self.channels) {\n                        return $log.error(new Error(\"No channel found\"));\n                    }\n\n                    var c = null;\n                    self.channels.some(function(channel) {\n                        if (channel.name === name) {\n                            c = channel;\n                            return true;\n                        }\n                        return false;\n                    });\n                    return c || self.channels[0];\n                };\n\n                /**\n                 * Sends messages stored in the queue\n                 * @param channel\n                 * @returns {boolean}\n                 */\n                self.sendChannelQueueMessages = function (channel) {\n                    if (channel && channel.connected && self.queue[channel.name].length) {\n                        self.queue[channel.name].forEach(function(msg, index) {\n                            delete self.queue[channel.name][index];\n                            channel.send(msg);\n                        });\n                        self.queue[channel.name].splice(0);\n                        return true;\n                    }\n                    return false;\n                };\n\n                return {\n                    start: self.initSocket,\n                    stop: self.closeSocket,\n                    initChannel: self.initChannel,\n                    send: self.send,\n                    on: self.on,\n                    socket: function() {\n                        return self.socket;\n                    }\n                };\n            }\n\n\n            this.$get = socketFactory;\n\n            this.configure = function(opt) {\n                angular.extend(options, opt);\n            };\n\n        });\n});\n"],"sourceRoot":"/source/"}